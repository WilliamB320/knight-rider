#include <ESP32Servo.h>

// **** Pin-konfiguration ****
const int TRIG_FRONT      = 13;
const int ECHO_FRONT      = 12;
const int TRIG_LEFT       = 10;
const int ECHO_LEFT       = 8;
const int TRIG_RIGHT      = 7;
const int ECHO_RIGHT      = 6;
const int SERVO_PIN       = 9;
const int MOTOR_SPEED_PIN = A1;  // PWM f√∂r motorhastighet
const int MOTOR_DIR_PIN   = B1;  // Motorriktning
const int START_BUTTON_PIN = 3;  // Digital ing√•ng med intern pull-down

// **** Servo-inst√§llningar ****
const int servoStraight     = 120;   // Hjul i rakt l√§ge
const int servoLeftMax      = 180;  // Max v√§nstersv√§ng
const int servoRightMax     = 45;   // Max h√∂gersv√§ng
int currentServoAngle       = servoStraight;

// **** Sensorvariabler (cm) ****
int sensorFront = 100;
int sensorLeft  = 100;
int sensorRight = 100;

// **** Laterala tr√∂sklar ****
const int emergencyThreshold = 15;  // Om sensorv√§rde <15 cm, n√∂dkorrigering

// **** Proportionell styrning ****
float Kp              = 0.4;   // Proportionalfaktor
float lateralDeadZone = 30.0;  // D√∂dzon (cm)

// **** Motor/Styr State Machine ****
enum CarState { DRIVING, STOPPED };
CarState state = DRIVING;
const int frontStopDist  = 20;  // Stanna om hinder √§r n√§rmare (cm)
const int frontClearDist = 30;  // √Öteruppta k√∂rning om fritt (cm)
int motorSpeedVal       = 150;  // PWM-v√§rde f√∂r motorhastighet

Servo steeringServo;

// Funktion: L√§s avst√•nd fr√•n HC-SR04 (cm)
long readUltrasonicCM(int trigPin, int echoPin) {
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
  long duration = pulseIn(echoPin, HIGH);
  if (duration == 0) return 100;
  return duration / 58;
}

void setup() {
  Serial.begin(115200);
  delay(500);
  Serial.println("üîÑ Startar system...");

  // Initiera START-knapp med intern pull-down
  pinMode(START_BUTTON_PIN, INPUT_PULLDOWN);

  // Initiera sensorpinnar
  pinMode(TRIG_FRONT,      OUTPUT);
  pinMode(ECHO_FRONT,      INPUT);
  pinMode(TRIG_LEFT,       OUTPUT);
  pinMode(ECHO_LEFT,       INPUT);
  pinMode(TRIG_RIGHT,      OUTPUT);
  pinMode(ECHO_RIGHT,      INPUT);

  // Initiera motorpinnar
  pinMode(MOTOR_SPEED_PIN, OUTPUT);
  pinMode(MOTOR_DIR_PIN,   OUTPUT);

  // Initiera servo
  steeringServo.attach(SERVO_PIN);
  steeringServo.write(servoStraight);

  // H√•ll motor avst√§ngd tills START-knapp trycks
  analogWrite(MOTOR_SPEED_PIN, 0);
  digitalWrite(MOTOR_DIR_PIN, LOW);

  Serial.println("‚úÖ System klart! V√§ntar p√• START-knapp.");
}

void loop() {
  // --- L√§s START-knappen ---
  bool startPressed = digitalRead(START_BUTTON_PIN);
  if (!startPressed) {
    // Om inte tryckt: h√•ll motor avst√§ngd och centrerad servo
    analogWrite(MOTOR_SPEED_PIN, 0);
    steeringServo.write(servoStraight);
    delay(50);
    return;
  }

  // L√§s sensorer
  sensorFront = readUltrasonicCM(TRIG_FRONT, ECHO_FRONT);
  sensorLeft  = readUltrasonicCM(TRIG_LEFT, ECHO_LEFT);
  sensorRight = readUltrasonicCM(TRIG_RIGHT, ECHO_RIGHT);

  Serial.print("Front: "); Serial.print(sensorFront);
  Serial.print(" cm, Left: "); Serial.print(sensorLeft);
  Serial.print(" cm, Right: "); Serial.print(sensorRight);
  Serial.println(" cm");

  // Hantera stopp/start fram√•t
  if (state == DRIVING) {
    if (sensorFront < frontStopDist) {
      Serial.println("üö® Hinder fram! Stoppar.");
      analogWrite(MOTOR_SPEED_PIN, 0);
      state = STOPPED;
    }
  } else {
    if (sensorFront > frontClearDist) {
      Serial.println("‚úÖ V√§gen fri! K√∂r fram√•t.");
      digitalWrite(MOTOR_DIR_PIN, HIGH);
      analogWrite(MOTOR_SPEED_PIN, motorSpeedVal);
      state = DRIVING;
    }
  }

  // Ber√§kna m√•lservo (endast i DRIVING)
  int targetServo = servoStraight;
  if (state == DRIVING) {
    if (sensorRight < emergencyThreshold) {
      Serial.println("‚ÄºÔ∏è Akut: H√∂ger n√§ra ‚Üí v√§nster sv√§ng");
      targetServo = servoLeftMax;
    }
    else if (sensorLeft < emergencyThreshold) {
      Serial.println("‚ÄºÔ∏è Akut: V√§nster n√§ra ‚Üí h√∂ger sv√§ng");
      targetServo = servoRightMax;
    }
    else {
      float error = sensorLeft - sensorRight;
      if (fabs(error) < lateralDeadZone) {
        targetServo = servoStraight;
        Serial.println("‚úÖ Inom d√∂dzon");
      } else {
        targetServo = servoStraight + int(Kp * error);
        Serial.println("üîÑ Proportionell styrning: error=" + String(error));
      }
      targetServo = constrain(targetServo, servoRightMax, servoLeftMax);
    }
  }

  // Exponentiell smoothing
  currentServoAngle += (targetServo - currentServoAngle) / 4;
  steeringServo.write(currentServoAngle);
  Serial.print("Servo: "); Serial.println(currentServoAngle);

  // Se till att motorn √§r ig√•ng om vi k√∂r
  if (state == DRIVING) {
    digitalWrite(MOTOR_DIR_PIN, HIGH);
    analogWrite(MOTOR_SPEED_PIN, motorSpeedVal);
  }

  // Kort loop-delay (~50 Hz)
  delay(20);
}
