#include <Wire.h>
#include <OPT3101.h>
#include <ESP32Servo.h>   // Anv√§nder ESP32Servo-biblioteket

#define SERVO_PIN        9    // Servopinne
#define MOTOR_SPEED_PIN  A1   // PWM-pin f√∂r motorhastighet (enable-ing√•ng, M1A)
#define MOTOR_DIR_PIN    B1   // Digital utg√•ng f√∂r motorriktning (M1B)

// Konfigurera LEDC f√∂r PWM
#define MOTOR_PWM_CHANNEL    0
#define MOTOR_PWM_FREQUENCY  5000  // 5 kHz
#define MOTOR_PWM_RESOLUTION 8     // 8-bit (0-255)

Servo myservo;              // Anv√§nder standard Servo-typen (fr√•n ESP32Servo)
OPT3101 sensor;

// --- Servo-inst√§llningar ---
const int servoStraight = 90;    // Centervinkel n√§r bilen √§r centrerad
const int servoLeftMax  = 135;    // Max v√§nstersv√§ng
const int servoRightMax = 45;     // Max h√∂gersv√§ng
int servoPosition = servoStraight;

// --- Sensorvariabler (i mm) ---
// Kanal 0: H√∂ger, Kanal 1: Fram, Kanal 2: V√§nster
int sensorRight = 800;
int sensorFront = 800;
int sensorLeft  = 800;

// --- State machine f√∂r k√∂rning ---
enum DriveState { FORWARD, STOPPED, REVERSING };
DriveState driveState = FORWARD;
unsigned long stateChangeTime = 0;
const unsigned long stopDuration = 2000; // 2 sekunder stopp innan backning

// --- Motorinst√§llningar ---
int motorSpeedVal = 200;  // PWM-v√§rde (0-255); justera efter behov

void setup() {
  Serial.begin(115200);
  delay(1000);
  Serial.println("üîÑ Startar systemet...");

  // Initiera LEDC f√∂r motor PWM p√• MOTOR_SPEED_PIN (A1)
  ledcSetup(MOTOR_PWM_CHANNEL, MOTOR_PWM_FREQUENCY, MOTOR_PWM_RESOLUTION);
  ledcAttachPin(MOTOR_SPEED_PIN, MOTOR_PWM_CHANNEL);

  // Initiera I2C (om din Nano ESP32 anv√§nder A4 och A5 som SDA/SCL)
  Wire.begin(A4, A5);

  // Initiera OPT3101-sensorn
  sensor.init();
  if (sensor.getLastError()) {
    Serial.print("‚ùå Sensorfel: ");
    Serial.println(sensor.getLastError());
    while (1) {} // Stanna om sensorfel
  }
  sensor.configureDefault();
  sensor.setFrameTiming(32); // Du kan testa med ett l√§gre v√§rde om du vill snabbare m√§tningar
  sensor.setBrightness(OPT3101Brightness::High);
  sensor.enableTimingGenerator();
  sensor.setChannel(0);
  sensor.startSample();

  // Initiera servot
  myservo.attach(SERVO_PIN);
  myservo.write(servoStraight);

  // Initiera motorens riktningspinne
  pinMode(MOTOR_DIR_PIN, OUTPUT);
  
  // Starta motorn (fram√•triktning):
  // I detta exempel antas att fram√•t uppn√•s n√§r MOTOR_DIR_PIN √§r LOW.
  digitalWrite(MOTOR_DIR_PIN, LOW);
  ledcWrite(MOTOR_PWM_CHANNEL, motorSpeedVal);

  Serial.println("‚úÖ System klart!");
}

void loop() {
  unsigned long currentTime = millis();

  if (sensor.isSampleDone()) {
    sensor.readOutputRegs();
    int distance = sensor.distanceMillimeters;
    int channel = sensor.channelUsed;

    // Hoppa √∂ver ogiltiga m√§tningar
    if (distance == 0) {
      sensor.startSample();
      delay(100);
      return;
    }

    // Uppdatera sensorvariabler beroende p√• kanal
    if (channel == 0) {
      sensorRight = distance;
    } else if (channel == 1) {
      sensorFront = distance;
    } else if (channel == 2) {
      sensorLeft = distance;
    }

    // Debugutskrift
    Serial.print("Kanal ");
    Serial.print(channel);
    Serial.print(": ");
    Serial.print(distance);
    Serial.println(" mm");

    // V√§xla till n√§sta kanal (0 ‚Üí 1 ‚Üí 2 ‚Üí 0 ...)
    if (channel == 0)
      sensor.setChannel(1);
    else if (channel == 1)
      sensor.setChannel(2);
    else
      sensor.setChannel(0);
    sensor.startSample();

    // --- State Machine ---
    if (driveState == FORWARD) {
      // Om frontavst√•ndet √§r under 50 mm, stanna bilen
      if (sensorFront < 50) {
        Serial.println("üö® Hinder FRAMF√ñR! Stoppar bilen.");
        driveState = STOPPED;
        stateChangeTime = currentTime;
        // Stoppa motorn
        digitalWrite(MOTOR_DIR_PIN, LOW); // Riktningen kan s√§ttas, men vi stoppar PWM
        ledcWrite(MOTOR_PWM_CHANNEL, 0);
      }
      else {
        // Center-ekvation: ber√§kna error = sensorLeft - sensorRight
        int error = sensorLeft - sensorRight;
        if (abs(error) < 15) error = 0;  // Deadband

        // Anv√§nd olika Kp beroende p√• error:
        float Kp = (error > 0) ? 0.30 : 0.15;
        int newServo = servoStraight + (int)(Kp * error);
        if (newServo < servoRightMax) newServo = servoRightMax;
        if (newServo > servoLeftMax) newServo = servoLeftMax;

        if (servoPosition != newServo) {
          servoPosition = newServo;
          myservo.write(servoPosition);
          Serial.print("Servo justerat till: ");
          Serial.println(servoPosition);
        }
        // K√∂r fram√•t: f√∂rutsatt att fram√•t ges med MOTOR_DIR_PIN = LOW
        digitalWrite(MOTOR_DIR_PIN, LOW);
        ledcWrite(MOTOR_PWM_CHANNEL, motorSpeedVal);
      }
    }
    else if (driveState == STOPPED) {
      // V√§nta 2 sekunder innan vi b√∂rjar backa
      if (currentTime - stateChangeTime >= stopDuration) {
        Serial.println("‚û°Ô∏è 2 sekunder passerade. B√∂rjar backa.");
        driveState = REVERSING;
        servoPosition = servoStraight;
        myservo.write(servoPosition);
        // F√∂r backning: s√§tt MOTOR_DIR_PIN till HIGH (om detta ger back)
        digitalWrite(MOTOR_DIR_PIN, HIGH);
        ledcWrite(MOTOR_PWM_CHANNEL, motorSpeedVal);
        stateChangeTime = currentTime; // √Öterst√§ll tid f√∂r backning
      }
    }
    else if (driveState == REVERSING) {
      // I backl√§ge, om frontavst√•ndet √∂kar (√∂ver 100 mm) √•terg√• till FORWARD
      if (sensorFront > 100) {
        Serial.println("‚úÖ Hinder borta, √•terg√•r till fram√•tk√∂rning.");
        driveState = FORWARD;
        digitalWrite(MOTOR_DIR_PIN, LOW);
        ledcWrite(MOTOR_PWM_CHANNEL, motorSpeedVal);
      }
      // Vid backning h√•ll servot rakt
      myservo.write(servoStraight);
    }
  }
  delay(100);
}
