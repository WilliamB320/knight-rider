#include <Wire.h>
#include <OPT3101.h>
#include <ESP32Servo.h>

#define SERVO_PIN 9  
#define MOTOR_IN1 A1  
#define MOTOR_IN2 A2  
#define MOTOR_SPEED 8  

Servo myservo;
OPT3101 sensor;

// Servo-inst√§llningar
int servoStraight = 90;  
int servoLeft = 135;    // Aggressiv v√§nstersv√§ng (max)
int servoRight = 45;    // Aggressiv h√∂gersv√§ng (max)
int servoPosition = 90; // Aktuell servovinkel

// Variabler f√∂r sensoravl√§sningar (i mm)
// Kanal 0: H√∂ger, Kanal 1: Fram, Kanal 2: V√§nster
int lastDistance0 = 600;  // H√∂ger
int lastDistance1 = 600;  // Fram
int lastDistance2 = 600;  // V√§nster

unsigned long lastMotorToggle = 0;
const int motorInterval = 150;  // Kortare tidsintervall f√∂r motorpulser

// Tr√∂skelv√§rden (i mm)
const int hinderMin = 100;  
const int hinderMax = 400;  // √ñvre gr√§ns f√∂r att tolka avst√•nd f√∂r banf√∂ljning

int motorSpeed = 5;  // Mycket l√•g hastighet
bool motorOn = true;

void setup() {
  Serial.begin(115200);
  delay(1000);

  Serial.println("üîÑ Startar...");
  Wire.begin(A4, A5);

  sensor.init();
  if (sensor.getLastError()) {
    Serial.print("‚ùå Sensorfel: ");
    Serial.println(sensor.getLastError());
    while (1);
  }

  sensor.configureDefault();
  sensor.setFrameTiming(32);
  sensor.setBrightness(OPT3101Brightness::High);
  sensor.enableTimingGenerator();

  myservo.attach(SERVO_PIN);
  myservo.write(servoStraight);

  pinMode(MOTOR_IN1, OUTPUT);
  pinMode(MOTOR_IN2, OUTPUT);
  pinMode(MOTOR_SPEED, OUTPUT);
  
  // Starta motorn (f√∂rutsatt fram√•triktning)
  digitalWrite(MOTOR_IN1, HIGH);
  digitalWrite(MOTOR_IN2, LOW);
  analogWrite(MOTOR_SPEED, motorSpeed);  

  Serial.println("‚úÖ System klart!");
  // Starta med kanal 0 (h√∂ger)
  sensor.setChannel(0);
  sensor.startSample();
}

void loop() {
  unsigned long currentTime = millis();

  if (sensor.isSampleDone()) {
    sensor.readOutputRegs();
    int16_t distance = sensor.distanceMillimeters;
    int currentChannel = sensor.channelUsed;

    // Om ogiltigt v√§rde, hoppa √∂ver denna m√§tning
    if (distance == 0) {
      Serial.println("‚ö†Ô∏è Ogiltigt v√§rde - ignorerar!");
      sensor.startSample();
      delay(100);
      return;
    }

    // Uppdatera m√§tv√§rden f√∂r respektive kanal
    if (currentChannel == 0) {
      lastDistance0 = distance;  // H√∂ger
    } else if (currentChannel == 1) {
      lastDistance1 = distance;  // Fram
    } else if (currentChannel == 2) {
      lastDistance2 = distance;  // V√§nster
    }

    // Debugutskrift f√∂r aktuell kanal och avst√•nd
    Serial.print("üì° Kanal: ");
    Serial.print(currentChannel);
    Serial.print(" | Avst√•nd: ");
    Serial.print(distance);
    Serial.println(" mm");

    // V√§xla till n√§sta kanal (0->1->2->0...)
    if (currentChannel == 0) {
      sensor.setChannel(1);
    } else if (currentChannel == 1) {
      sensor.setChannel(2);
    } else {
      sensor.setChannel(0);
    }
    sensor.startSample();

    // Om ett hinder uppt√§cks rakt fram, stanna motorn
    if (lastDistance1 <= hinderMin) {
      Serial.println("üö® Hinder FRAMF√ñR! Motor STOPP!");
      digitalWrite(MOTOR_IN1, LOW);
      digitalWrite(MOTOR_IN2, LOW);
      analogWrite(MOTOR_SPEED, 0);
    } else {
      // R√§kna ut felv√§rdet baserat p√• v√§nster- och h√∂germ√§tning
      int error = lastDistance2 - lastDistance0;
      
      // Inf√∂r en deadband f√∂r sm√• fel (¬±15 mm)
      if (abs(error) < 15) {
        error = 0;
      }
      
      // Anv√§nd en proportionell konstant
      float Kp = 0.15;  
      int newServo = servoStraight + (int)(Kp * error);
      
      // Begr√§nsa servovinkeln till [servoRight, servoLeft]
      if (newServo < servoRight) newServo = servoRight;
      if (newServo > servoLeft) newServo = servoLeft;
      
      // Uppdatera servovinkeln om den har √§ndrats
      if (servoPosition != newServo) {
        servoPosition = newServo;
        myservo.write(servoPosition);
        Serial.print("Servo justerat till: ");
        Serial.println(servoPosition);
      }
      
      // Motorstyrning med pulserande hastighet
      if (currentTime - lastMotorToggle > motorInterval) {
        motorOn = !motorOn;
        if (motorOn) {
          digitalWrite(MOTOR_IN1, HIGH);
          digitalWrite(MOTOR_IN2, LOW);
          analogWrite(MOTOR_SPEED, motorSpeed);
        } else {
          analogWrite(MOTOR_SPEED, 0);
        }
        lastMotorToggle = currentTime;
      }
    }
    delay(100);  // Kortare delay f√∂r snabbare reaktion
  }
}
