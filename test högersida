#include <Wire.h>
#include <OPT3101.h>
#include <ESP32Servo.h>   // Inkluderar ESP32Servo-biblioteket

#define SERVO_PIN      9    // Servopinne
#define MOTOR_IN1      A1   // H-bryggans IN1
#define MOTOR_IN2      A2   // H-bryggans IN2
#define MOTOR_SPEED    8    // PWM-pin f√∂r motor (m√•ste vara PWM-kompatibel)

Servo myservo;             // Anv√§nd standard Servo-klass
OPT3101 sensor;

// --- Servo-inst√§llningar ---
const int servoStraight = 90;    // Centervinkel (om bilen √§r centrerad)
const int servoLeftMax  = 135;    // Max v√§nstersv√§ng (om bilen √§r f√∂r n√§ra h√∂ger)
const int servoRightMax = 45;     // Max h√∂gersv√§ng (om bilen √§r f√∂r n√§ra v√§nster)
int servoPosition = servoStraight;

// --- Sensorvariabler (i mm) ---
// Kanal 0: H√∂ger, Kanal 1: Fram, Kanal 2: V√§nster
int sensorRight = 800;
int sensorFront = 800;
int sensorLeft  = 800;

// --- State machine f√∂r k√∂rning ---
enum DriveState { FORWARD, STOPPED, REVERSING };
DriveState driveState = FORWARD;
unsigned long stateChangeTime = 0;
const unsigned long stopDuration = 2000; // 2 sekunder i stoppat l√§ge innan backning

// --- Motorinst√§llningar ---
int motorSpeedVal = 5;  // L√•g hastighet (0-255)
unsigned long lastMotorToggle = 0;
const int motorInterval = 150;  // Motorpulseringsintervall (ms)

void setup() {
  Serial.begin(115200);
  delay(1000);
  Serial.println("üîÑ Startar systemet...");

  // Initiera I2C (p√• ESP32 kan du specificera SDA, SCL om n√∂dv√§ndigt)
  Wire.begin(A4, A5);

  // Initiera OPT3101-sensorn
  sensor.init();
  if (sensor.getLastError()) {
    Serial.print("‚ùå Sensorfel: ");
    Serial.println(sensor.getLastError());
    while (1) {} // Stanna om sensorfel
  }
  sensor.configureDefault();
  sensor.setFrameTiming(32);
  sensor.setBrightness(OPT3101Brightness::High);
  sensor.enableTimingGenerator();

  // Initiera servot
  myservo.attach(SERVO_PIN);
  myservo.write(servoStraight);

  // Initiera motorpinnar
  pinMode(MOTOR_IN1, OUTPUT);
  pinMode(MOTOR_IN2, OUTPUT);
  pinMode(MOTOR_SPEED, OUTPUT);

  // Starta motorn (fram√•triktning)
  digitalWrite(MOTOR_IN1, HIGH);
  digitalWrite(MOTOR_IN2, LOW);
  analogWrite(MOTOR_SPEED, motorSpeedVal);

  Serial.println("‚úÖ System klart!");

  // Starta med kanal 0 (h√∂ger) p√• sensorn
  sensor.setChannel(0);
  sensor.startSample();
}

void loop() {
  unsigned long currentTime = millis();

  if (sensor.isSampleDone()) {
    sensor.readOutputRegs();
    int distance = sensor.distanceMillimeters;
    int channel = sensor.channelUsed;

    // Hoppa √∂ver ogiltiga m√§tningar
    if (distance == 0) {
      sensor.startSample();
      delay(100);
      return;
    }

    // Uppdatera sensorvariabler beroende p√• kanal
    if (channel == 0) {
      sensorRight = distance;
    } else if (channel == 1) {
      sensorFront = distance;
    } else if (channel == 2) {
      sensorLeft = distance;
    }

    // Debugutskrift
    Serial.print("Kanal ");
    Serial.print(channel);
    Serial.print(": ");
    Serial.print(distance);
    Serial.println(" mm");

    // V√§xla till n√§sta kanal (0 -> 1 -> 2 -> 0 ...)
    if (channel == 0)
      sensor.setChannel(1);
    else if (channel == 1)
      sensor.setChannel(2);
    else
      sensor.setChannel(0);
    sensor.startSample();

    // --- State Machine ---
    if (driveState == FORWARD) {
      // Om frontavst√•ndet √§r under 50 mm, stanna bilen
      if (sensorFront < 50) {
        Serial.println("üö® Hinder FRAMF√ñR! Stoppar bilen.");
        driveState = STOPPED;
        stateChangeTime = currentTime;
        digitalWrite(MOTOR_IN1, LOW);
        digitalWrite(MOTOR_IN2, LOW);
        analogWrite(MOTOR_SPEED, 0);
      }
      else {
        // Center-ekvation: ber√§kna error = sensorLeft - sensorRight
        int error = sensorLeft - sensorRight;
        if (abs(error) < 15) error = 0;  // Deadband

        // Anv√§nd olika Kp beroende p√• error:
        float Kp = (error > 0) ? 0.30 : 0.15;
        int newServo = servoStraight + (int)(Kp * error);
        if (newServo < servoRightMax) newServo = servoRightMax;
        if (newServo > servoLeftMax) newServo = servoLeftMax;

        if (servoPosition != newServo) {
          servoPosition = newServo;
          myservo.write(servoPosition);
          Serial.print("Servo justerat till: ");
          Serial.println(servoPosition);
        }
        // K√∂r fram√•t
        digitalWrite(MOTOR_IN1, HIGH);
        digitalWrite(MOTOR_IN2, LOW);
        analogWrite(MOTOR_SPEED, motorSpeedVal);
      }
    }
    else if (driveState == STOPPED) {
      // V√§nta 2 sekunder innan vi b√∂rjar backa
      if (currentTime - stateChangeTime >= stopDuration) {
        Serial.println("‚û°Ô∏è 2 sekunder passerade. B√∂rjar backa.");
        driveState = REVERSING;
        servoPosition = servoStraight;
        myservo.write(servoPosition);
        // √Ñndra motorriktning: s√§tt MOTOR_IN1 LOW, MOTOR_IN2 HIGH (backa)
        digitalWrite(MOTOR_IN1, LOW);
        digitalWrite(MOTOR_IN2, HIGH);
        analogWrite(MOTOR_SPEED, motorSpeedVal);
      }
    }
    else if (driveState == REVERSING) {
      // I backl√§ge, om frontavst√•ndet √∂kar (√∂ver 100 mm) √•terg√• till FORWARD
      if (sensorFront > 100) {
        Serial.println("‚úÖ Hinder borta, √•terg√•r till fram√•tk√∂rning.");
        driveState = FORWARD;
        digitalWrite(MOTOR_IN1, HIGH);
        digitalWrite(MOTOR_IN2, LOW);
        analogWrite(MOTOR_SPEED, motorSpeedVal);
      }
      // Under backning h√•ll servot rakt
      myservo.write(servoStraight);
    }
  }
  delay(100);
}
