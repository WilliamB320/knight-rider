#include <Wire.h>
#include <OPT3101.h>
#include <ESP32Servo.h>

#define SERVO_PIN       9    // Servopinne
#define MOTOR_SPEED_PIN A1   // PWM-pin f√∂r motorhastighet (enable-ing√•ng, M1A)
#define MOTOR_DIR_PIN   B1   // Digital utg√•ng f√∂r motorriktning (M1B)

Servo myservo;             // Anv√§nd Servo-typen fr√•n ESP32Servo-biblioteket
OPT3101 sensor;

// --- Servo-inst√§llningar ---
const int servoStraight = 90;    // Centervinkel n√§r bilen √§r centrerad
const int servoLeftMax  = 135;    // Max v√§nstersv√§ng (om hinder p√• h√∂ger)
const int servoRightMax = 45;     // Max h√∂gersv√§ng (om hinder p√• v√§nster)
int servoPosition = servoStraight;

// --- Sensorvariabler (i mm) ---
// Kanal 0: H√∂ger, Kanal 1: Fram, Kanal 2: V√§nster
int sensorRight = 800;
int sensorFront = 800;
int sensorLeft  = 800;

// --- Tr√∂skelv√§rden f√∂r mapping (justera efter behov) ---
const int Safe    = 800;   // √ñvre gr√§ns f√∂r "s√§kert" avst√•nd
const int NotSafe = 600;   // Nedre gr√§ns f√∂r att trigga sv√§ng

// --- State machine f√∂r k√∂rning ---
enum DriveState { FORWARD, STOPPED, REVERSING };
DriveState driveState = FORWARD;
unsigned long stateChangeTime = 0;
const unsigned long stopDuration = 2000; // 2 sekunder i stoppat l√§ge innan backning

// --- Motorinst√§llningar ---
int motorSpeedVal = 225;  // PWM-v√§rde (0-255); justera efter behov

void setup() {
  Serial.begin(115200);
  
  Serial.println("üîÑ Startar systemet...");

  // Initiera I2C (om din Nano ESP32 anv√§nder A4 och A5 som SDA/SCL)
  Wire.begin(A4, A5);

  // Initiera OPT3101-sensorn
  sensor.init();
  if (sensor.getLastError()) {
    Serial.print("‚ùå Sensorfel: ");
    Serial.println(sensor.getLastError());
    while (1) {}
  }
  sensor.configureDefault();
  sensor.setFrameTiming(32);
  sensor.setBrightness(OPT3101Brightness::High);
  sensor.enableTimingGenerator();
  sensor.setChannel(0);
  sensor.startSample();

  // Initiera servot
  myservo.attach(SERVO_PIN);
  myservo.write(servoStraight);

  // Initiera motorpinnar
  pinMode(MOTOR_SPEED_PIN, OUTPUT);
  pinMode(MOTOR_DIR_PIN, OUTPUT);

  // Starta motorn i fram√•triktning: (fram = digital LOW)
  digitalWrite(MOTOR_DIR_PIN, LOW);
  analogWrite(MOTOR_SPEED_PIN, motorSpeedVal);

  Serial.println("‚úÖ System klart!");
}

void loop() {
  unsigned long currentTime = millis();

  if (sensor.isSampleDone()) {
    sensor.readOutputRegs();
    int distance = sensor.distanceMillimeters;
    int channel = sensor.channelUsed;

    // Hoppa √∂ver ogiltiga m√§tningar
    if (distance == 0) {
      sensor.startSample();
      return;
    }

    // Uppdatera sensorvariabler
    if (channel == 0) {
      sensorRight = distance;
    } else if (channel == 1) {
      sensorFront = distance;
    } else if (channel == 2) {
      sensorLeft = distance;
    }

    // Debugutskrift
    Serial.print("Kanal ");
    Serial.print(channel);
    Serial.print(": ");
    Serial.print(distance);
    Serial.println(" mm");

    // V√§xla till n√§sta kanal (0 -> 1 -> 2 -> 0)
    if (channel == 0)
      sensor.setChannel(1);
    else if (channel == 1)
      sensor.setChannel(2);
    else
      sensor.setChannel(0);
    sensor.startSample();

    // --- State Machine ---
    if (driveState == FORWARD) {
      // Om frontavst√•ndet √§r under 50 mm, stanna bilen
      if (sensorFront < 50) {
        Serial.println("üö® Hinder FRAMF√ñR! Stoppar bilen.");
        driveState = STOPPED;
        stateChangeTime = currentTime;
        digitalWrite(MOTOR_DIR_PIN, LOW);
        analogWrite(MOTOR_SPEED_PIN, 0);
      }
      else {
        int newServo = servoStraight;  // Standard: rakt fram

        // Om det finns ett hinder p√• v√§nster sida (l√§gre sensorv√§rde) √§n p√• h√∂ger, sv√§ng h√∂ger
        if (sensorLeft < Safe && sensorLeft < sensorRight) {
          // Mappa fr√•n avst√•ndet (NotSafe till Safe) till servo-vinkel (servoRightMax till servoStraight)
          newServo = map(sensorLeft, NotSafe, Safe, servoRightMax, servoStraight);
          Serial.println("üîÑ Hinder p√• v√§nster sida, sv√§nger h√∂ger.");
        }
        // Om det finns ett hinder p√• h√∂ger sida √§n p√• v√§nster, sv√§ng v√§nster
        else if (sensorRight < Safe && sensorRight < sensorLeft) {
          // Mappa fr√•n avst√•ndet (NotSafe till Safe) till servo-vinkel (servoLeftMax till servoStraight)
          newServo = map(sensorRight, NotSafe, Safe, servoLeftMax, servoStraight);
          Serial.println("üîÑ Hinder p√• h√∂ger sida, sv√§nger v√§nster.");
        }
        else {
          // Annars anv√§nd proportionell styrning med felber√§kning (sensorLeft - sensorRight)
          int error = sensorLeft - sensorRight;
          if (abs(error) < 30) error = 0;  // Deadband
          float Kp = 0.10;
          newServo = servoStraight + (int)(Kp * error);
        }

        // Se till att servovinkeln h√•ller sig inom gr√§nserna
        if (newServo < servoRightMax) newServo = servoRightMax;
        if (newServo > servoLeftMax) newServo = servoLeftMax;

        if (servoPosition != newServo) {
          servoPosition = newServo;
          myservo.write(servoPosition);
          Serial.print("Servo justerat till: ");
          Serial.println(servoPosition);
        }
        // K√∂r fram√•t: s√§tt motorriktning till LOW (fram)
        digitalWrite(MOTOR_DIR_PIN, LOW);
        analogWrite(MOTOR_SPEED_PIN, motorSpeedVal);
      }
    }
    else if (driveState == STOPPED) {
      // V√§nta 2 sekunder innan vi b√∂rjar backa
      if (currentTime - stateChangeTime >= stopDuration) {
        Serial.println("‚û°Ô∏è 2 sekunder passerade. B√∂rjar backa.");
        driveState = REVERSING;
        servoPosition = servoStraight;
        myservo.write(servoPosition);
        // F√∂r backning: s√§tt motorriktning till HIGH (back)
        digitalWrite(MOTOR_DIR_PIN, HIGH);
        analogWrite(MOTOR_SPEED_PIN, motorSpeedVal);
      }
    }
    else if (driveState == REVERSING) {
      // Om frontavst√•ndet √∂kar (√∂ver 100 mm) √•terg√• till FORWARD
      if (sensorFront > 100) {
        Serial.println("‚úÖ Hinder borta, √•terg√•r till fram√•tk√∂rning.");
        driveState = FORWARD;
        digitalWrite(MOTOR_DIR_PIN, LOW);
        analogWrite(MOTOR_SPEED_PIN, motorSpeedVal);
      }
      // Under backning h√•ll servot rakt
      myservo.write(servoStraight);
    }
  }
}
